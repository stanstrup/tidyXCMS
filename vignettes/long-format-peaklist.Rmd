---
title: "Creating Long-Format Peak Tables with Optional Annotations"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Creating Long-Format Peak Tables with Optional Annotations}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Introduction

The `tidyXCMS` package provides functions to work with XCMS metabolomics data in
a tidy, long-format structure. This vignette demonstrates how to use the
`XCMSnExp_CAMERA_peaklist_long()` function to create peak tables from XCMS results.

The resulting long-format table has one row per feature per sample, integrating:

- Peak detection results from XCMS
- Feature grouping (correspondence) information
- Sample metadata

This structure makes the data ideal for downstream analysis with tidyverse tools
like `dplyr` and `ggplot2`.

You can optionally enhance these tables with additional annotations, which we'll
explore later in this vignette.

# Setup

```{r setup, message=FALSE}
library(tidyXCMS)
library(xcms)
library(MSnbase)
library(CAMERA)
library(MsFeatures)
library(commonMZ)
library(BiocParallel)
library(dplyr)
library(ggplot2)
library(tidyr)
library(MsExperiment)
library(ggalluvial)
library(RColorBrewer)
library(ggpie)
```

# Example Workflow

## Load Example Data

We'll use the `xmse` dataset from XCMS, which contains preprocessed LC-MS data from
wild-type and knockout samples. This dataset already has peak detection and feature
grouping completed.

```{r load_data, message=FALSE}
# Load example data from XCMS (already preprocessed)
xdata <- loadXcmsData("xmse")
```

### Examine Sample Metadata

Let's check what sample information is available:

```{r check_sample_data, message=FALSE}
sampleData(xdata)

# Check results
cat("Dataset contains", nrow(chromPeaks(xdata)), "peaks across",
    length(unique(chromPeaks(xdata)[, "sample"])), "samples,",
    "grouped into", nrow(featureDefinitions(xdata)), "features\n")
```

### Fix File Paths

The example data contains file paths from the original system. We need to update them to match the current system:

```{r fix_paths, message=FALSE}
# Get the correct base path for faahKO package on this system
cdf_path <- file.path(find.package("faahKO"), "cdf")

# Create a mapping table with old and new paths
path_mapping <- tibble(
  old_path = unique(spectra(xdata)$dataOrigin)
) %>%
  mutate(
    # Extract relative paths (e.g., "KO/ko15.CDF", "WT/wt15.CDF")
    relative_path = sub(".*/faahKO/cdf/", "", old_path),
    # Reconstruct full paths for this system
    new_path = file.path(cdf_path, relative_path)
  )

# Join with spectra dataOrigin and replace
spectra_df <- tibble(dataOrigin = spectra(xdata)$dataOrigin) %>%
  left_join(path_mapping, by = c("dataOrigin" = "old_path"))

spectra(xdata)$dataOrigin <- spectra_df$new_path
```

## Creating a Basic Long-Format Peak Table

Let's start by creating a long-format peak table directly from the XCMS results. This gives us all the essential peak information in a tidy format.

```{r create_table_no_camera}
# Create basic peak table
peak_table <- XCMSnExp_CAMERA_peaklist_long(xdata)

# Check the structure
dim(peak_table)

# View first few rows
head(peak_table)

# Check column names
colnames(peak_table)
```

The resulting table contains all feature and peak information from XCMS, organized with one row per feature per sample.

## Enhancing Peak Tables with CAMERA Annotations

CAMERA can annotate isotopes, adducts, and group features into pseudospectra, providing valuable chemical context to your peak table.

**Note:** CAMERA requires an `xcmsSet` object. Since our data is an `XcmsExperiment`, we first convert it to `XCMSnExp` and then to `xcmsSet`.

### Creating a CAMERA object

In this first step we create a CAMERA object from the XCMS object. We specify the polarity to help CAMERA determine appropriate adducts and fragments.

```{r camera_setup, message=FALSE}
# Convert XcmsExperiment to xcmsSet for CAMERA (required for compatibility)
# Two-step conversion: XcmsExperiment -> XCMSnExp -> xcmsSet
xset <- xdata %>%
  as("XCMSnExp") %>%
  as("xcmsSet")

# Create xsAnnotate object with polarity
xs <- xsAnnotate(xset, polarity = "positive")
```

### Grouping coeluting peaks

The first step to grouping features is to group co-eluting peaks. This is a naÃ¯ve approach that we will refine later.

```{r camera_groupfwhm, message=FALSE}
# Group peaks by retention time
xs <- groupFWHM(xs, perfwhm = 0.1, intval = "into", sigma = 6)
```

### Grouping based on correlation

Now we group the features based on correlations. This looks at each group from the previous step and splits them into separate groups for peaks that correlate with each other.

**Note:** For this small example dataset, don't use correlation across samples as it is unreliable with this few samples.

```{r camera_groupcorr, message=FALSE}
# Group by correlation
xs <- groupCorr(xs, calcIso = FALSE, calcCiS = TRUE, calcCaS = FALSE, cor_eic_th = 0.7, pval = 1E-6)
```

### Isotope annotation

This annotates peaks that are possible isotopes based on m/z difference and intensity patterns.

```{r camera_isotopes, message=FALSE}
# Find isotopes
xs <- findIsotopes(xs, ppm = 10, mzabs = 0.01, intval = "into", maxcharge = 2)
```

### Annotation of adducts and fragments

Now we try to annotate adducts and fragments based on expected mass differences. We'll use the `commonMZ` package to generate a comprehensive list of adduct and fragment rules for CAMERA.

First, we get the adduct/fragment rules for positive mode:

```{r camera_rules_filter, message=FALSE}
# warn_clash=TRUE will warn about indistinguishable annotations (e.g., [M+NH4]+ vs -NH3)
# Remove [M+NH4]+ if it's less common in your data

rules_pos <- MZ_CAMERA(mode = "pos", warn_clash = TRUE, clash_ppm = 5) %>%
  filter(name != "[M+NH4]+") %>%
  as.data.frame()
```

Now we can annotate adducts using these rules:

```{r camera_adducts, message=FALSE}
# Find adducts using the rules from commonMZ
xs <- findAdducts(xs, ppm = 500, mzabs = 0.2, multiplier = 4, polarity = "positive", rules = rules_pos)
```

### Creating the Peak Table with CAMERA Annotations

Now we can create a peak table that includes all the CAMERA annotations. We pass both the original `xdata` object and the CAMERA annotations from `xs`:

```{r create_table}
peak_table_camera <- XCMSnExp_CAMERA_peaklist_long(xdata, xs)

# Check the structure
dim(peak_table_camera)
colnames(peak_table_camera)
```

The table now includes additional columns for CAMERA annotations: `isotopes`, `adduct`, and `pcgroup` (pseudospectrum correlation group).

## Enhancing Peak Tables with MsFeatures Grouping

The `MsFeatures` package offers another way to enhance peak tables by grouping features based on retention time similarity, abundance correlation, or EIC similarity.

### Why Use MsFeatures?

- **Retention Time Grouping**: Group co-eluting features that likely come from the same compound
- **Abundance Correlation**: Group features with correlated intensities across samples
- **EIC Similarity**: Group features based on similar extracted ion chromatograms
- **Stepwise Refinement**: Apply multiple grouping algorithms sequentially to refine groups

### Applying Feature Grouping

The `groupFeatures()` function adds a `feature_group` column to the feature definitions. Let's demonstrate with retention time-based grouping:

```{r msfeatures_grouping, message=FALSE}
# Group features with similar retention times (within 10 seconds)
xdata_grouped <- groupFeatures(xdata, param = SimilarRtimeParam(diffRt = 10))

# Check feature groups in featureDefinitions
head(featureDefinitions(xdata_grouped)$feature_group)

# Count how many feature groups were created
table(featureDefinitions(xdata_grouped)$feature_group)
```

### Creating Peak Table with MsFeatures Grouping

When you create a long-format peak table from an object with feature groups, the `feature_group` column is automatically included:

```{r create_table_grouped}
# Create peak table with feature grouping
peak_table_grouped <- XCMSnExp_CAMERA_peaklist_long(xdata_grouped)

# Check that feature_group column is present
"feature_group" %in% colnames(peak_table_grouped)

# View some feature groups
peak_table_grouped %>%
  select(feature_id, feature_group, f_mzmed, f_rtmed) %>%
  distinct() %>%
  head(10)
```

## Combining CAMERA and MsFeatures Annotations

You can also combine both approaches. Apply `groupFeatures()` first, then proceed with CAMERA annotation:

```{r combined_annotation, message=FALSE}
# Apply feature grouping
xdata_grouped <- groupFeatures(xdata, param = SimilarRtimeParam(diffRt = 10))

# Create peak table with both CAMERA and MsFeatures annotations
# Reuse the xs object created earlier (CAMERA annotations are the same)
peak_table_combined <- XCMSnExp_CAMERA_peaklist_long(xdata_grouped, xs)

# View combined annotations
peak_table_combined %>%
  filter(adduct != "") %>%
  select(feature_id, feature_group, f_mzmed, f_rtmed, isotopes, adduct, pcgroup) %>%
  distinct(feature_id, .keep_all = TRUE) %>%
  head()
```



Now you have both:

- **`feature_group`**: Groups features based on retention time (from MsFeatures)
- **`pcgroup`**: Groups features into pseudospectra (from CAMERA)
- **`isotopes`** and **`adduct`**: Isotope and adduct annotations (from CAMERA)

This combined approach gives you multiple perspectives on which features might originate from the same compound.

\

We can also visually compare the mapping.

```{r, fig.width=7, fig.height=10, fig.alt="Alluvium diagram showing the flow and mapping between MsFeatures groupings (left) and CAMERA pseudospectrum groups (right). Each colored flow represents features that belong to specific groups in both systems."}
group_mapping <- peak_table_combined %>%
  filter(adduct != "") %>%
  select(feature_id, feature_group, f_mzmed, f_rtmed, isotopes, adduct, pcgroup) %>%
  distinct(feature_id, .keep_all = TRUE)

# Determine ordering by the most common pairs
order_group_mapping <- group_mapping %>%
  count(feature_group, pcgroup, sort = TRUE)

# Choose ordering to align best-matching pairs
left_order  <- unique(order_group_mapping$feature_group)
right_order <- unique(order_group_mapping$pcgroup)

group_mapping <- group_mapping %>%
  mutate(
    feature_group = factor(feature_group, levels = left_order),
    pcgroup       = factor(pcgroup,       levels = right_order)
  )

ggplot(group_mapping, aes(axis1 = feature_group, axis2 = pcgroup, fill = feature_group)) +
  geom_alluvium(alpha = 0.7) +
  geom_stratum() +
  geom_text(stat = "stratum", aes(label = after_stat(stratum))) +
  theme_minimal() +
  labs(x = "", y = "Count", title = "Flow between groupings A and B") +
  guides(fill="none") +
  scale_fill_manual(values = rep(brewer.pal(12, "Set3"), length.out = length(unique(group_mapping$feature_group))))

```


Or just look at those that are not mapped the same by CAMERA and groupFeatures.

```{r, fig.width=7, fig.height=6, fig.alt="Alluvium diagram filtered to show only cases where MsFeatures groups map to multiple CAMERA pseudospectrum groups or vice versa, highlighting discrepancies between the two grouping methods."}
group_mapping_different <- group_mapping %>%
  group_by(feature_group) %>%
  mutate(n_pc = n_distinct(pcgroup)) %>%
  group_by(pcgroup) %>%
  mutate(n_fg = n_distinct(feature_group)) %>%
  ungroup() %>%
  filter(n_pc > 1 | n_fg > 1)


ggplot(group_mapping_different, aes(axis1 = feature_group, axis2 = pcgroup, fill = feature_group)) +
  geom_alluvium(alpha = 0.7) +
  geom_stratum() +
  geom_text(stat = "stratum", aes(label = after_stat(stratum))) +
  theme_minimal() +
  labs(x = "", y = "Count", title = "Flow between groupings A and B") +
  guides(fill="none") +
  scale_fill_manual(values = rep(brewer.pal(12, "Set3"), length.out = length(unique(group_mapping_different$feature_group))))
```



# Understanding the Output

The resulting tibble contains comprehensive information about each feature in each sample. Below is a complete description of all columns:

## Column Reference Table

The table has been organized into logical groups for easier understanding:

| Column | Content |
|--------|---------|
| **Sample information** |
| `filepath` | Path to the raw data file |
| `filename` | The filename without path |
| `fromFile` | The file number (the order files were supplied in) |
| *Plus any columns from `sampleData()`* | Sample metadata columns (e.g., sample_name, sample_group, sample_type) |
| **Feature identifiers** |
| `feature_id` | The index of the feature after grouping across samples |
| `peakidx` | The index of the peak before grouping across samples |
| **Feature-level m/z statistics (across all samples)** |
| `f_mzmed` | The median m/z found for that feature **across samples** |
| `f_mzmin` | The minimum m/z found for that feature across samples |
| `f_mzmax` | The maximum m/z found for that feature across samples |
| **Feature-level retention time statistics (across all samples)** |
| `f_rtmed` | The median retention time found for that feature across samples |
| `f_rtmin` | The minimum retention time found for that feature across samples |
| `f_rtmax` | The maximum retention time found for that feature across samples |
| **CAMERA annotations** |
| `isotopes` | The isotope annotation from CAMERA (e.g., "[M]+", "[M+1]+", "[M+2]+") |
| `adduct` | The adduct annotation from CAMERA (e.g., "[M+H]+", "[M+Na]+", "[M+NH4]+") |
| `pcgroup` | The feature grouping index from CAMERA - features with same ID likely come from the same compound |
| **MsFeatures annotations** |
| `feature_group` | The feature group ID from MsFeatures (e.g., "FG.001", "FG.002") - features with same ID are grouped by retention time, abundance correlation, or EIC similarity |
| **Peak-level m/z measurements (in that specific sample)** |
| `mz` | The median m/z found for that feature in **that sample** |
| `mzmin` | The minimum m/z found for that feature in that sample |
| `mzmax` | The maximum m/z found for that feature in that sample |
| **Peak-level retention time measurements (in that specific sample)** |
| `rt` | The retention time found for that feature in that sample |
| `rtmin` | The minimum retention time found for that feature in that sample |
| `rtmax` | The maximum retention time found for that feature in that sample |
| **Peak intensity measurements** |
| `into` | The area under the peak |
| `intb` | The area under the peak after baseline removal |
| `maxo` | The maximum intensity (i.e., height) of the peak |
| `sn` | The signal to noise ratio of that peak |
| **Gaussian peak fitting parameters** |
| `egauss` | RMSE of Gaussian fit |
| `mu` | Gaussian parameter mu (center of the Gaussian; unit is scan number) |
| `sigma` | Gaussian parameter sigma |
| `h` | Gaussian parameter h (height of the Gaussian peak) |
| **CentWave algorithm parameters** |
| `f` | Region number of m/z ROI where the peak was localized |
| `dppm` | m/z deviation of mass trace across scans in ppm |
| `scale` | Scale on which the peak was localized |
| `scpos` | Center of peak position found by wavelet analysis |
| `scmin` | Left peak limit found by wavelet analysis (scan number) |
| `scmax` | Right peak limit found by wavelet analysis (scan number) |
| **Additional columns** |
| `ms_level` | MS level (e.g., MS1, MS2) |
| `is_filled` | Was the intensity found by gap filling (TRUE) or peak picking (FALSE) |

**Important notes:**

- **Each row represents one feature in one sample**
- If a feature was not detected in a sample, peak-level columns (mz, rt, into, etc.) will be `NA`
- Feature-level statistics (f_mzmed, f_rtmed, etc.) are always present and represent values across all samples
- CAMERA annotations (isotopes, adduct, pcgroup) are optional and only present when xsAnnotate is provided
- MsFeatures annotations (feature_group) are optional and only present when groupFeatures() was applied
- Both CAMERA and MsFeatures annotations apply at the feature level and are the same across all samples for a given feature
- The distinction between "feature-level" and "peak-level" is important:
  - **Feature-level** (prefix `f_`): Statistics aggregated across all samples
  - **Peak-level** (no prefix): Values for the specific peak in that specific sample

## Feature-Level Information

These columns describe each feature (grouped peak):

```{r feature_info}
peak_table %>%
  select(feature_id, f_mzmed, f_rtmed) %>%
  distinct() %>%
  head()
```

## CAMERA Annotations

When CAMERA annotations are included, these additional columns are available:

- `isotopes`: Isotope annotation (e.g., "[M]+", "[M+1]+")
- `adduct`: Adduct annotation (e.g., "[M+H]+", "[M+Na]+")
- `pcgroup`: Pseudospectrum correlation group ID

```{r camera_info}
# View features with adduct annotations (using the CAMERA-annotated table)
peak_table_camera %>%
  filter(adduct!="") %>%
  select(feature_id, f_mzmed, f_rtmed, isotopes, adduct, pcgroup) %>%
  distinct(feature_id, .keep_all = TRUE) %>%
  head()
```

## Peak-Level Information

For each feature in each sample:

- `mz`, `rt`: Detected peak position
- `into`: Integrated peak intensity
- `intb`: Baseline-corrected intensity
- `maxo`: Maximum intensity
- `sn`: Signal-to-noise ratio

```{r peak_info}
# View detected peaks (non-NA intensities)
peak_table %>%
  filter(!is.na(into)) %>%
  select(feature_id, filename, mz, rt, into, sn) %>%
  head()
```

## Sample Information

- `filename`, `filepath`: Sample file information
- `fromFile`: Sample index
- Plus any columns from `sampleData()` (sample metadata)

```{r sample_info}
peak_table %>%
  select(feature_id, filename, sample_name, sample_group, sample_type) %>%
  head()
```

## Missing Values

Features not detected in a sample have `NA` for peak-level columns:

```{r missing_values}
# Count for each feature how many samples the peak was found in
peak_table %>%
  group_by(feature_id, f_mzmed, f_rtmed) %>%
  summarise(
    n_samples_detected = sum(!is.na(into)),
    n_samples_total = n(),
    detection_rate = n_samples_detected / n_samples_total,
    .groups = "drop"
  ) %>%
  arrange(desc(detection_rate))
```

# Downstream Analysis Examples

## Visualize Feature Intensities

```{r plot_intensities, fig.width=7, fig.height=4, fig.alt="Boxplot showing the distribution of log10-transformed feature intensities across sample groups. The plot displays the median, quartiles, and outliers for each group."}
# Plot intensity distribution by sample group
peak_table %>%
  filter(feature_id == 10) %>%
  ggplot(aes(x = sample_group, y = log10(into), fill = sample_group)) +
  geom_boxplot() +
  labs(
    title = "Feature Intensity Distribution",
    x = "Sample Group",
    y = "log10(Intensity)"
  ) +
  theme_minimal()
```

## Identify Features with Adduct Annotations

```{r adduct_summary}
# Count features by adduct type (using the CAMERA-annotated table)
adduct_counts <- peak_table_camera %>%
  filter(adduct!="") %>%
  separate_rows(adduct, sep = "\\s(?=\\[M)") %>%
  distinct(feature_id, adduct) %>%
  mutate(adduct = gsub("^(\\[.*\\].*\\+).*","\\1",adduct)) %>%

  count(adduct, sort = TRUE)

adduct_counts
```

### Visualize Adduct Distribution

We can create a pie chart showing the frequency of different adducts and fragments found by CAMERA:

```{r adduct_pie, fig.width=7, fig.height=7, fig.alt="Pie chart showing the distribution of adduct and fragment annotations found by CAMERA across all features.", warning=FALSE}
# Create pie chart of adduct frequencies
adduct_counts %>% 
  mutate(count = n) %>% 
    ggpie(data = ., 
          group_key = "adduct", 
          count_type = "count",
          label_info = "group", 
          label_type = "circle",
          label_size = 4, 
          label_pos = "out"
          ) +
    guides(fill="none") +
    ggtitle("Distribution of Adduct Annotations")



```


## Filter Non-Informative Features with D-ratio

The D-ratio helps identify features that are more variable in pooled samples (QC) than in biological samples, indicating they are likely measurement noise rather than biological signal.

### Calculate Standard Deviation per Sample Type

First, we calculate the standard deviation for each feature in each sample type:

```{r d_ratio_sd}
# Calculate SD for each feature by sample type
# Note: Using sample_group as proxy for sample_type (WT/KO as biological samples)
# In a real analysis with QC samples, you would filter for sample_type == "QC" or "PS"
feature_sd <- peak_table %>%
  filter(!is.na(into)) %>%
  select(sample_group, feature_id, f_mzmed, f_rtmed, into) %>%
  group_by(sample_group, feature_id, f_mzmed, f_rtmed) %>%
  summarise(sd = sd(into, na.rm = TRUE), .groups = "drop")

head(feature_sd)
```

### Calculate D-ratio

The D-ratio is the ratio of SD in pooled samples to SD in biological samples:

```{r d_ratio_calc}
# Calculate D-ratio
# In a real analysis, you would have "PS" (pooled samples) and "sample" groups
# Here we'll calculate it between the two groups as an example
feature_d <- feature_sd %>%
  pivot_wider(names_from = "sample_group", values_from = sd) %>%
  mutate(D_ratio = KO / WT)  # Example: comparing variability between groups

head(feature_d)
```

### Visualize D-ratio Distribution

```{r d_ratio_plot, fig.width=7, fig.height=4, fig.alt="Density plot showing the distribution of D-ratio values across features"}
# Plot D-ratio distribution
feature_d %>%
  filter(!is.na(D_ratio) & is.finite(D_ratio)) %>%
  ggplot(aes(x = D_ratio)) +
  geom_density(alpha = 0.7, fill = "steelblue") +
  geom_vline(xintercept = 0.5, linetype = "dashed", color = "red") +
  labs(
    title = "D-ratio Distribution",
    x = "D-ratio",
    y = "Density"
  ) +
  theme_bw()
```

### Count Features by D-ratio Threshold

```{r d_ratio_count}
# Count features that would be kept with D_ratio < 0.5 threshold
feature_d %>%
  filter(!is.na(D_ratio) & is.finite(D_ratio)) %>%
  summarise(
    total_features = n(),
    features_kept = sum(D_ratio < 0.5),
    features_removed = sum(D_ratio >= 0.5),
    percent_kept = round(features_kept / total_features * 100, 1)
  )
```

**Note:** In a real metabolomics study with QC pooled samples, you would:

1. Filter for `sample_type == "PS"` (pooled samples) and `sample_type == "sample"` (biological samples)
2. Calculate SD for each group
3. Use D-ratio to filter out features with high variability in QC relative to biological samples
4. A typical threshold is D-ratio < 0.5 (features more stable in QC than biological samples should be removed)

## Extract Specific Features for Further Analysis

```{r extract_features}
# Get a specific feature across all samples
feature_123 <- peak_table %>%
  filter(feature_id == 123) %>%
  select(feature_id, filename, sample_group, mz, rt, into)

head(feature_123)
```

# Session Info

```{r session_info}
sessionInfo()
```
